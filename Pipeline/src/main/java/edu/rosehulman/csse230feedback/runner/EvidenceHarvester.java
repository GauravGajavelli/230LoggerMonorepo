package edu.rosehulman.csse230feedback.runner;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import edu.rosehulman.csse230feedback.model.EnrichedTestResult;
import edu.rosehulman.csse230feedback.model.TestStatus;
import edu.rosehulman.csse230feedback.util.Json;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * Harvests enriched test evidence from the run.tar generated by test execution.
 * Extracts testRunInfo.json and parses the evidence data for each test.
 */
public class EvidenceHarvester {

    private static final String RUN_TAR_FILENAME = "run.tar";
    private static final String TEST_RUN_INFO_FILENAME = "testRunInfo.json";
    private static final ObjectMapper MAPPER = Json.mapper();

    // Reserved field names in testRunInfo.json (not test classes)
    private static final Set<String> RESERVED_FIELDS = Set.of(
        "prevRunNumber", "randomSeed", "redactDiffs", "rebaselining",
        "toIgnore", "skipLogging", "strikes", "prevBaselineRunNumber", "runTimes"
    );

    /**
     * Result of harvesting evidence from a workspace.
     */
    public record HarvestResult(
        int runNumber,
        List<EnrichedTestResult> results,
        List<String> warnings
    ) {}

    /**
     * Harvests test evidence from the run.tar in the workspace.
     *
     * @param workspace Path to workspace root
     * @return HarvestResult containing enriched test results
     * @throws IOException if tar extraction or parsing fails
     */
    public HarvestResult harvest(Path workspace) throws IOException {
        Path runTarPath = workspace.resolve("src").resolve("testSupport").resolve(RUN_TAR_FILENAME);
        List<String> warnings = new ArrayList<>();

        if (!Files.exists(runTarPath)) {
            warnings.add("run.tar not found at " + runTarPath);
            return new HarvestResult(-1, List.of(), warnings);
        }

        // Extract and parse testRunInfo.json from tar
        JsonNode testRunInfo = extractTestRunInfo(runTarPath, warnings);
        if (testRunInfo == null) {
            return new HarvestResult(-1, List.of(), warnings);
        }

        int runNumber = testRunInfo.path("prevRunNumber").asInt(-1);
        List<EnrichedTestResult> results = parseEnrichedResults(testRunInfo, runNumber, warnings);

        return new HarvestResult(runNumber, results, warnings);
    }

    /**
     * Harvests evidence and copies run.tar to output directory.
     *
     * @param workspace Path to workspace root
     * @param outDir Output directory for harvested artifacts
     * @param runId Identifier for the run (used in output filename)
     * @return HarvestResult containing enriched test results
     * @throws IOException if operations fail
     */
    public HarvestResult harvestAndCopy(Path workspace, Path outDir, String runId) throws IOException {
        HarvestResult result = harvest(workspace);

        // Copy run.tar to output
        Path runTarPath = workspace.resolve("src").resolve("testSupport").resolve(RUN_TAR_FILENAME);
        if (Files.exists(runTarPath)) {
            Files.createDirectories(outDir);
            Path targetPath = outDir.resolve("run_" + runId + ".tar");
            Files.copy(runTarPath, targetPath);
        }

        // Write enriched results as JSON
        if (!result.results().isEmpty()) {
            Path resultsPath = outDir.resolve("enriched_" + runId + ".json");
            MAPPER.writerWithDefaultPrettyPrinter().writeValue(resultsPath.toFile(), result.results());
        }

        return result;
    }

    /**
     * Extracts testRunInfo.json from run.tar.
     */
    private JsonNode extractTestRunInfo(Path runTarPath, List<String> warnings) throws IOException {
        try (InputStream fis = Files.newInputStream(runTarPath);
             BufferedInputStream bis = new BufferedInputStream(fis);
             TarArchiveInputStream tis = new TarArchiveInputStream(bis)) {

            TarArchiveEntry entry;
            while ((entry = tis.getNextTarEntry()) != null) {
                if (entry.getName().equals(TEST_RUN_INFO_FILENAME) ||
                    entry.getName().endsWith("/" + TEST_RUN_INFO_FILENAME)) {
                    return MAPPER.readTree(tis);
                }
            }
        }

        warnings.add("testRunInfo.json not found in run.tar");
        return null;
    }

    /**
     * Parses enriched test results from testRunInfo.json.
     */
    private List<EnrichedTestResult> parseEnrichedResults(JsonNode testRunInfo, int runNumber,
            List<String> warnings) {
        List<EnrichedTestResult> results = new ArrayList<>();

        Iterator<String> fieldNames = testRunInfo.fieldNames();
        while (fieldNames.hasNext()) {
            String fieldName = fieldNames.next();

            // Skip reserved fields
            if (RESERVED_FIELDS.contains(fieldName)) {
                continue;
            }

            // This is a test class
            String testClassName = fieldName;
            JsonNode testClassNode = testRunInfo.get(testClassName);

            if (!testClassNode.isObject()) {
                continue;
            }

            // Iterate through test methods
            Iterator<String> testNames = testClassNode.fieldNames();
            while (testNames.hasNext()) {
                String testName = testNames.next();
                JsonNode testNode = testClassNode.get(testName);

                if (!testNode.isObject()) {
                    continue;
                }

                // Get status for this run
                String runKey = String.valueOf(runNumber);
                JsonNode runNode = testNode.get(runKey);
                if (runNode == null || !runNode.isObject()) {
                    continue;
                }

                String statusStr = runNode.path("status").asText();
                TestStatus status = parseStatus(statusStr, warnings);
                String cause = extractCause(statusStr);

                // Get evidence for this run (nested inside the run node)
                JsonNode evidenceNode = runNode.path("evidence");

                Long durationMs = null;
                String stackTrace = null;
                String exceptionType = null;
                String message = null;
                String expected = null;
                String actual = null;
                String uniqueId = null;

                if (!evidenceNode.isMissingNode() && evidenceNode.isObject()) {
                    durationMs = evidenceNode.has("durationMs") ?
                        evidenceNode.get("durationMs").asLong() : null;
                    stackTrace = evidenceNode.has("stackTrace") ?
                        evidenceNode.get("stackTrace").asText() : null;
                    exceptionType = evidenceNode.has("exceptionType") ?
                        evidenceNode.get("exceptionType").asText() : null;
                    message = evidenceNode.has("message") ?
                        evidenceNode.get("message").asText() : null;
                    expected = evidenceNode.has("expected") ?
                        evidenceNode.get("expected").asText() : null;
                    actual = evidenceNode.has("actual") ?
                        evidenceNode.get("actual").asText() : null;
                    uniqueId = evidenceNode.has("uniqueId") ?
                        evidenceNode.get("uniqueId").asText() : null;
                }

                EnrichedTestResult result = EnrichedTestResult.create(
                    testClassName, testName, status, cause,
                    durationMs, stackTrace, exceptionType, message, expected, actual, uniqueId
                );
                results.add(result);
            }
        }

        // Sort by test ID
        results.sort(Comparator.comparing(EnrichedTestResult::testId));
        return results;
    }

    /**
     * Parses test status from status string (may include cause).
     */
    private TestStatus parseStatus(String statusStr, List<String> warnings) {
        if (statusStr == null || statusStr.isEmpty()) {
            return TestStatus.ABORTED;
        }

        // Status may be "SUCCESSFUL" or "FAILED: some cause"
        String statusPart = statusStr.contains(":") ?
            statusStr.substring(0, statusStr.indexOf(':')).trim() : statusStr.trim();

        try {
            return TestStatus.valueOf(statusPart.toUpperCase());
        } catch (IllegalArgumentException e) {
            warnings.add("Unknown status: " + statusPart);
            return TestStatus.ABORTED;
        }
    }

    /**
     * Extracts the cause portion from a status string like "FAILED: cause".
     */
    private String extractCause(String statusStr) {
        if (statusStr == null || !statusStr.contains(":")) {
            return null;
        }
        return statusStr.substring(statusStr.indexOf(':') + 1).trim();
    }
}
